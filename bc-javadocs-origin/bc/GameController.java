/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.12
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package bc;

public class GameController {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  protected GameController(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  protected static long getCPtr(GameController obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

//  protected void finalize() {
//    delete();
//  }
//
//  public synchronized void delete() {
//    if (swigCPtr != 0) {
//      if (swigCMemOwn) {
//        swigCMemOwn = false;
//        bcJNI.delete_GameController(swigCPtr);
//      }
//      swigCPtr = 0;
//    }
//  }

  /**
   * Connect to the manager. Only call once in the program.
   */
  public GameController() {
    this(bcJNI.new_GameController(), true);
  }

  /**
   * Send the moves from the current turn and wait for the next turn.
   */
  public void nextTurn() {
    bcJNI.GameController_nextTurn(swigCPtr, this);
  }

  /**
   * Get time remaining in timing pool in milliseconds.
   */
  public int getTimeLeftMs() {
    return bcJNI.GameController_getTimeLeftMs(swigCPtr, this);
  }

  /**
   * The current round, starting at round 1 and up to ROUND_LIMIT rounds. A round consists of a turn from each team on each planet.
   */
  public long round() {
    return bcJNI.GameController_round(swigCPtr, this);
  }

  /**
   * The current planet.
   */
  public Planet planet() {
    return Planet.swigToEnum(bcJNI.GameController_planet(swigCPtr, this));
  }

  /**
   * The team whose turn it is.
   */
  public Team team() {
    return Team.swigToEnum(bcJNI.GameController_team(swigCPtr, this));
  }

  /**
   * The starting map of the given planet. Includes the map's planet, dimensions, impassable terrain, and initial units and karbonite.
   */
  public PlanetMap startingMap(Planet planet) {
    long cPtr = bcJNI.GameController_startingMap(swigCPtr, this, planet.swigValue());
    return (cPtr == 0) ? null : new PlanetMap(cPtr, true);
  }

  /**
   * The karbonite in the team's resource pool.
   */
  public long karbonite() {
    return bcJNI.GameController_karbonite(swigCPtr, this);
  }

  /**
   * The single unit with this ID.
   * Use this method to get detailed statistics on a unit - heat, cooldowns, and properties of special abilities
   * like units garrisoned in a rocket.
   *
   * <dl>
   *     <dt><span class="strong">Throws:</span></dt>
   *     <dd>NoSuchUnit - If the unit does not exist (inside the vision range).</dd>
   * </dl>
   */
  public Unit unit(int id) {
    long cPtr = bcJNI.GameController_unit(swigCPtr, this, id);
    return (cPtr == 0) ? null : new Unit(cPtr, true);
  }

  /**
   * All the units within the vision range, in no particular order. Does not include units in space.
   */
  public VecUnit units() {
    long cPtr = bcJNI.GameController_units(swigCPtr, this);
    return (cPtr == 0) ? null : new VecUnit(cPtr, true);
  }

  /**
   * All the units on your team. Does not include units in space.
   */
  public VecUnit myUnits() {
    long cPtr = bcJNI.GameController_myUnits(swigCPtr, this);
    return (cPtr == 0) ? null : new VecUnit(cPtr, true);
  }

  /**
   * All the units of this team that are in space. You cannot see units on the other team that are in space.
   */
  public VecUnit unitsInSpace() {
    long cPtr = bcJNI.GameController_unitsInSpace(swigCPtr, this);
    return (cPtr == 0) ? null : new VecUnit(cPtr, true);
  }

  /**
   * The karbonite at the given location.
   *
   * <dl>
   *     <dt><span class="strong">Throws:</span></dt>
   *     <dd>LocationOffMap - If the location is off the map.</dd>
   *     <dd>LocationNotVisible - If the location is outside the vision range.</dd>
   * </dl>
   */
  public long karboniteAt(MapLocation location) {
    return bcJNI.GameController_karboniteAt(swigCPtr, this, MapLocation.getCPtr(location), location);
  }

  /**
   * Returns an array of all locations within a certain radius squared of this location that are on the map.
   * The locations are ordered first by the x-coordinate, then the y-coordinate. The radius squared is inclusive.
   */
  public VecMapLocation allLocationsWithin(MapLocation location, long radius_squared) {
    long cPtr = bcJNI.GameController_allLocationsWithin(swigCPtr, this, MapLocation.getCPtr(location), location, radius_squared);
    return (cPtr == 0) ? null : new VecMapLocation(cPtr, true);
  }

  /**
   * Whether the location is on the map and within the vision range.
   */
  public boolean canSenseLocation(MapLocation location) {
    return bcJNI.GameController_canSenseLocation(swigCPtr, this, MapLocation.getCPtr(location), location);
  }

  /**
   * Whether there is a unit with this ID within the vision range.
   */
  public boolean canSenseUnit(int id) {
    return bcJNI.GameController_canSenseUnit(swigCPtr, this, id);
  }

  /**
   * Sense units near the location within the given radius, inclusive, in distance squared.
   * The units are within the vision range.
   */
  public VecUnit senseNearbyUnits(MapLocation location, long radius) {
    long cPtr = bcJNI.GameController_senseNearbyUnits(swigCPtr, this, MapLocation.getCPtr(location), location, radius);
    return (cPtr == 0) ? null : new VecUnit(cPtr, true);
  }

  /**
   * Sense units near the location within the given radius, inclusive, in distance squared.
   * The units are within the vision range. Additionally filters the units by team.
   */
  public VecUnit senseNearbyUnitsByTeam(MapLocation location, long radius, Team team) {
    long cPtr = bcJNI.GameController_senseNearbyUnitsByTeam(swigCPtr, this, MapLocation.getCPtr(location), location, radius, team.swigValue());
    return (cPtr == 0) ? null : new VecUnit(cPtr, true);
  }

  /**
   * Sense units near the location within the given radius, inclusive, in distance squared.
   * The units are within the vision range. Additionally filters the units by unit type.
   */
  public VecUnit senseNearbyUnitsByType(MapLocation location, long radius, UnitType unit_type) {
    long cPtr = bcJNI.GameController_senseNearbyUnitsByType(swigCPtr, this, MapLocation.getCPtr(location), location, radius, unit_type.swigValue());
    return (cPtr == 0) ? null : new VecUnit(cPtr, true);
  }

  /**
   * Whether there is a visible unit at a location.
   */
  public boolean hasUnitAtLocation(MapLocation location) {
    return bcJNI.GameController_hasUnitAtLocation(swigCPtr, this, MapLocation.getCPtr(location), location);
  }

  /**
   * The unit at the location, if it exists.
   *
   * <dl>
   *     <dt><span class="strong">Throws:</span></dt>
   *     <dd>LocationOffMap - If the location is off the map.</dd>
   *     <dd>LocationNotVisible - If the location is outside the vision range.</dd>
   * </dl>
   */
  public Unit senseUnitAtLocation(MapLocation location) {
    long cPtr = bcJNI.GameController_senseUnitAtLocation(swigCPtr, this, MapLocation.getCPtr(location), location);
    return (cPtr == 0) ? null : new Unit(cPtr, true);
  }

  /**
   * The asteroid strike pattern on Mars.
   */
  public AsteroidPattern asteroidPattern() {
    long cPtr = bcJNI.GameController_asteroidPattern(swigCPtr, this);
    return (cPtr == 0) ? null : new AsteroidPattern(cPtr, true);
  }

  /**
   * The orbit pattern that determines a rocket's flight duration.
   */
  public OrbitPattern orbitPattern() {
    long cPtr = bcJNI.GameController_orbitPattern(swigCPtr, this);
    return (cPtr == 0) ? null : new OrbitPattern(cPtr, true);
  }

  /**
   * The current duration of flight if a rocket were to be launched this round.
   * Does not take into account any research done on rockets.
   */
  public long currentDurationOfFlight() {
    return bcJNI.GameController_currentDurationOfFlight(swigCPtr, this);
  }

  /**
   * Gets a read-only version of this planet's team array.
   * If the given planet is different from the planet of the player, reads the version of the planet's team array from
   * COMMUNICATION_DELAY rounds prior.
   */
  public Veci32 getTeamArray(Planet planet) {
    long cPtr = bcJNI.GameController_getTeamArray(swigCPtr, this, planet.swigValue());
    return (cPtr == 0) ? null : new Veci32(cPtr, true);
  }

  /**
   * Writes the value at the index of this planet's team array.
   *
   * <dl>
   *     <dt><span class="strong">Throws:</span></dt>
   *     <dd>ArrayOutOfBounds - If the index of the array is out of bounds.
   *     It must be within [0, COMMUNICATION_ARRAY_LENGTH).</dd>
   * </dl>
   */
  public void writeTeamArray(long index, int value) {
    bcJNI.GameController_writeTeamArray(swigCPtr, this, index, value);
  }

  /**
   * Disintegrates the unit and removes it from the map.
   * If the unit is a factory or a rocket, also disintegrates any units garrisoned inside it.
   *
   * <dl>
   *     <dt><span class="strong">Throws:</span></dt>
   *     <dd>NoSuchUnit - if the unit does not exist (inside the vision range).</dd>
   *     <dd>TeamNotAllowed - if the unit is not on the current player's team.</dd>
   * </dl>
   */
  public void disintegrateUnit(int unit_id) {
    bcJNI.GameController_disintegrateUnit(swigCPtr, this, unit_id);
  }

  /**
   * Whether the location is clear for a unit to occupy, either by movement or by construction.
   *
   * <dl>
   *     <dt><span class="strong">Throws:</span></dt>
   *     <dd>LocationOffMap - If the location is off the map.</dd>
   *     <dd>LocationNotVisible - If the location is outside the vision range.</dd>
   * </dl>
   */
  public short isOccupiable(MapLocation location) {
    return bcJNI.GameController_isOccupiable(swigCPtr, this, MapLocation.getCPtr(location), location);
  }

  /**
   * Whether the robot can move in the given direction, without taking into account the unit's movement heat.
   * Takes into account only the map terrain, positions of other robots, and the edge of the game map.
   */
  public boolean canMove(int robot_id, Direction direction) {
    return bcJNI.GameController_canMove(swigCPtr, this, robot_id, direction.swigValue());
  }

  /**
   * Whether the robot is ready to move. Tests whether the robot's attack heat is sufficiently low.
   */
  public boolean isMoveReady(int robot_id) {
    return bcJNI.GameController_isMoveReady(swigCPtr, this, robot_id);
  }

  /**
   * Moves the robot in the given direction.
   *
   * <dl>
   *     <dt><span class="strong">Throws:</span></dt>
   *     <dd>NoSuchUnit - If the robot does not exist (within the vision range).</dd>
   *     <dd>TeamNotAllowed - If the robot is not on the current player's team.</dd>
   *     <dd>UnitNotOnMap - If the robot is not on the map.</dd>
   *     <dd>LocationNotVisible - If the location is outside the vision range.</dd>
   *     <dd>LocationOffMap - If the location in the target direction is off the map.</dd>
   *     <dd>LocationNotEmpty - If the location in the target direction is occupied by a unit or terrain.</dd>
   *     <dd>Overheated - If the robot is not ready to move again.</dd>
   * </dl>
   */
  public void moveRobot(int robot_id, Direction direction) {
    bcJNI.GameController_moveRobot(swigCPtr, this, robot_id, direction.swigValue());
  }

  /**
   * Whether the robot can attack the given unit, without taking into account the robot's attack heat.
   * Takes into account only the robot's attack range, and the location of the robot and target.
   * Healers cannot attack, and should use {@link #canHeal(int, int) canHeal()} instead.
   */
  public boolean canAttack(int robot_id, int target_unit_id) {
    return bcJNI.GameController_canAttack(swigCPtr, this, robot_id, target_unit_id);
  }

  /**
   * Whether the robot is ready to attack. Tests whether the robot's attack heat is sufficiently low.
   * Healers cannot attack, and should use {@link #isHealReady(int) isHealReady()} instead.
   */
  public boolean isAttackReady(int robot_id) {
    return bcJNI.GameController_isAttackReady(swigCPtr, this, robot_id);
  }

  /**
   * Commands a robot to attack a unit, dealing the robot's standard amount of damage.
   * Healers cannot attack, and should use {@link #heal(int, int) heal()} instead.
   *
   * <dl>
   *     <dt><span class="strong">Throws:</span></dt>
   *     <dd>NoSuchUnit - If the robot does not exist (within the vision range).</dd>
   *     <dd>TeamNotAllowed - If the robot is not on the current player's team.</dd>
   *     <dd>InappropriateUnitType - If the unit is not a robot, or is a healer.</dd>
   *     <dd>UnitNotOnMap - If the robot is not on the map.</dd>
   *     <dd>OutOfRange - If the target location is not in range.</dd>
   *     <dd>Overheated - If the robot is not ready to attack.</dd>
   * </dl>
   */
  public void attack(int robot_id, int target_unit_id) {
    bcJNI.GameController_attack(swigCPtr, this, robot_id, target_unit_id);
  }

  /**
   * The research info of the current team, including what branch is currently being researched and the number of rounds left.
   */
  public ResearchInfo researchInfo() {
    long cPtr = bcJNI.GameController_researchInfo(swigCPtr, this);
    return (cPtr == 0) ? null : new ResearchInfo(cPtr, true);
  }

  /**
   * Resets the research queue to be empty. Returns true if the queue was not empty before, and false otherwise.
   */
  public short resetResearch() {
    return bcJNI.GameController_resetResearch(swigCPtr, this);
  }

  /**
   * Adds a branch to the back of the queue, if it is a valid upgrade, and starts research if it is the first in the queue.
   * Returns whether the branch was successfully added.
   */
  public short queueResearch(UnitType branch) {
    return bcJNI.GameController_queueResearch(swigCPtr, this, branch.swigValue());
  }

  /**
   * Whether the worker is ready to harvest, and the given direction contains karbonite to harvest.
   * The worker cannot already have performed an action this round.
   */
  public boolean canHarvest(int worker_id, Direction direction) {
    return bcJNI.GameController_canHarvest(swigCPtr, this, worker_id, direction.swigValue());
  }

  /**
   * Harvests up to the worker's harvest amount of karbonite from the given location, adding it to the team's resource pool.
   *
   * <dl>
   *     <dt><span class="strong">Throws:</span></dt>
   *     <dd>NoSuchUnit - If the worker does not exist (within the vision range).</dd>
   *     <dd>TeamNotAllowed - If the worker is not on the current player's team.</dd>
   *     <dd>InappropriateUnitType - If the unit is not a worker.</dd>
   *     <dd>Overheated - If the worker has already performed an action this turn.</dd>
   *     <dd>UnitNotOnMap - If the worker is not on the map.</dd>
   *     <dd>LocationOffMap - If the location in the target direction is off the map.</dd>
   *     <dd>LocationNotVisible - If the location in the target direction is not in the vision range.</dd>
   *     <dd>KarboniteDepositEmpty - If the location described contains no Karbonite.</dd>
   * </dl>
   */
  public void harvest(int worker_id, Direction direction) {
    bcJNI.GameController_harvest(swigCPtr, this, worker_id, direction.swigValue());
  }

  /**
   * Whether the worker can blueprint a unit of the given type.
   * The worker can only blueprint factories, and rockets if Rocketry has been researched.
   * The team must have sufficient karbonite in its resource pool.
   * The worker cannot already have performed an action this round.
   */
  public boolean canBlueprint(int worker_id, UnitType unit_type, Direction direction) {
    return bcJNI.GameController_canBlueprint(swigCPtr, this, worker_id, unit_type.swigValue(), direction.swigValue());
  }

  /**
   * Blueprints a unit of the given type in the given direction. Subtract cost of that unit from the team's resource pool.
   *
   * <dl>
   *     <dt><span class="strong">Throws:</span></dt>
   *     <dd>NoSuchUnit - If the worker does not exist (within the vision range).</dd>
   *     <dd>TeamNotAllowed - If the worker is not on the current player's team.</dd>
   *     <dd>InappropriateUnitType - If the unit is not a worker, or the unit type is not a structure.</dd>
   *     <dd>Overheated - If the worker has already performed an action this turn.</dd>
   *     <dd>UnitNotOnMap - If the unit is not on the map.</dd>
   *     <dd>LocationOffMap - If the location in the target direction is off the map.</dd>
   *     <dd>LocationNotVisible - If the location in the target direction is not in the vision range.</dd>
   *     <dd>LocationNotEmpty - If the location in the target direction is already occupied.</dd>
   *     <dd>CannotBuildOnMars - If you cannot blueprint a structure on Mars.</dd>
   *     <dd>ResearchNotUnlocked - If you do not have the needed research to blueprint rockets.</dd>
   *     <dd>InsufficientKarbonite - If your team does not have enough Karbonite to build the requested structure.</dd>
   * </dl>
   */
  public void blueprint(int worker_id, UnitType structure_type, Direction direction) {
    bcJNI.GameController_blueprint(swigCPtr, this, worker_id, structure_type.swigValue(), direction.swigValue());
  }

  /**
   * Whether the worker can build a blueprint with the given ID.
   * The worker and the blueprint must be adjacent to each other.
   * The worker cannot already have performed an action this round.
   */
  public boolean canBuild(int worker_id, int blueprint_id) {
    return bcJNI.GameController_canBuild(swigCPtr, this, worker_id, blueprint_id);
  }

  /**
   * Builds a given blueprint, increasing its health by the worker's build amount.
   * If raised to maximum health, the blueprint becomes a completed structure.
   *
   * <dl>
   *     <dt><span class="strong">Throws:</span></dt>
   *     <dd>NoSuchUnit - If either unit does not exist (within the vision range).</dd>
   *     <dd>TeamNotAllowed - If either unit is not on the current player's team.</dd>
   *     <dd>UnitNotOnMap - If the unit is not on the map.</dd>
   *     <dd>InappropriateUnitType - If the unit is not a worker, or the blueprint is not a structure.</dd>
   *     <dd>Overheated - If the worker has already performed an action this turn.</dd>
   *     <dd>OutOfRange - If the worker is not adjacent to the blueprint.</dd>
   *     <dd>StructureAlreadyBuilt - If the blueprint has already been completed. </dd>
   * </dl>
   */
  public void build(int worker_id, int blueprint_id) {
    bcJNI.GameController_build(swigCPtr, this, worker_id, blueprint_id);
  }

  /**
   * Whether the given worker can repair the given structure.
   * Tests that the worker is able to execute a worker action, that the structure is built, and that the structure is within range.
   */
  public boolean canRepair(int worker_id, int structure_id) {
    return bcJNI.GameController_canRepair(swigCPtr, this, worker_id, structure_id);
  }

  /**
   * Commands the worker to repair a structure, repleneshing health to it. This can only be done to structures which have been fully built.
   *
   * <dl>
   *     <dt><span class="strong">Throws:</span></dt>
   *     <dd>NoSuchUnit - If either unit does not exist (within the vision range).</dd>
   *     <dd>TeamNotAllowed - If either unit is not on the current player's team.</dd>
   *     <dd>UnitNotOnMap - If the unit is not on the map.</dd>
   *     <dd>InappropriateUnitType - If the unit is not a worker, or the target is not a structure.</dd>
   *     <dd>Overheated - If the worker has already performed an action this turn.</dd>
   *     <dd>OutOfRange - If the worker is not adjacent to the structure.</dd>
   *     <dd>StructureNotYetBuilt - If the structure has not been completed. </dd>
   * </dl>
   */
  public void repair(int worker_id, int structure_id) {
    bcJNI.GameController_repair(swigCPtr, this, worker_id, structure_id);
  }

  /**
   * Whether the worker is ready to replicate.
   * Tests that the worker's ability heat is sufficiently low, that the team has sufficient karbonite in its resource pool,
   * and that the square in the given direction is empty.
   */
  public boolean canReplicate(int worker_id, Direction direction) {
    return bcJNI.GameController_canReplicate(swigCPtr, this, worker_id, direction.swigValue());
  }

  /**
   * Replicates a worker in the given direction. Subtracts the cost of the worker from the team's resource pool.
   *
   * <dl>
   *     <dt><span class="strong">Throws:</span></dt>
   *     <dd>NoSuchUnit - If the worker does not exist (within the vision range).</dd>
   *     <dd>TeamNotAllowed - If the worker is not on the current player's team.</dd>
   *     <dd>InappropriateUnitType - If the unit is not a worker.</dd>
   *     <dd>Overheated - If the worker is not ready to replicate again.</dd>
   *     <dd>InsufficientKarbonite - If your team does not have enough Karbonite for the worker to replicate.</dd>
   *     <dd>UnitNotOnMap - If the worker is not on the map.</dd>
   *     <dd>LocationOffMap - If the location in the target direction is off the map.</dd>
   *     <dd>LocationNotVisible - If the location in the target direction is not in the vision range.</dd>
   *     <dd>LocationNotEmpty - If the location in the target direction is already occupied.</dd>
   * </dl>
   */
  public void replicate(int worker_id, Direction direction) {
    bcJNI.GameController_replicate(swigCPtr, this, worker_id, direction.swigValue());
  }

  /**
   * Whether the knight can javelin the given robot, without taking into account the knight's ability heat.
   * Takes into account only the knight's ability range, and the location of the robot.
   */
  public boolean canJavelin(int knight_id, int target_unit_id) {
    return bcJNI.GameController_canJavelin(swigCPtr, this, knight_id, target_unit_id);
  }

  /**
   * Whether the knight is ready to javelin. Tests whether the knight's ability heat is sufficiently low.
   */
  public boolean isJavelinReady(int knight_id) {
    return bcJNI.GameController_isJavelinReady(swigCPtr, this, knight_id);
  }

  /**
   * Javelins the robot, dealing the knight's standard damage.
   *
   * <dl>
   *     <dt><span class="strong">Throws:</span></dt>
   *     <dd>NoSuchUnit - If either unit does not exist (within the vision range).</dd>
   *     <dd>TeamNotAllowed - If the knight is not on the current player's team.</dd>
   *     <dd>UnitNotOnMap - If the knight is not on the map.</dd>
   *     <dd>InappropriateUnitType - If the unit is not a knight.</dd>
   *     <dd>ResearchNotUnlocked - If you do not have the needed research to use javelin.</dd>
   *     <dd>OutOfRange - If the target does not lie within ability range of the knight.</dd>
   *     <dd>Overheated - If the knight is not ready to use javelin again.</dd>
   * </dl>
   */
  public void javelin(int knight_id, int target_unit_id) {
    bcJNI.GameController_javelin(swigCPtr, this, knight_id, target_unit_id);
  }

  /**
   * Whether the ranger can begin to snipe the given location, without taking into account the ranger's ability heat.
   * Takes into account only the target location and the unit's type and unlocked abilities.
   */
  public boolean canBeginSnipe(int ranger_id, MapLocation location) {
    return bcJNI.GameController_canBeginSnipe(swigCPtr, this, ranger_id, MapLocation.getCPtr(location), location);
  }

  /**
   * Whether the ranger is ready to begin snipe. Tests whether the ranger's ability heat is sufficiently low.
   */
  public boolean isBeginSnipeReady(int ranger_id) {
    return bcJNI.GameController_isBeginSnipeReady(swigCPtr, this, ranger_id);
  }

  /**
   * Begins the countdown to snipe a given location.
   * Maximizes the units attack and movement heats until the ranger has sniped.
   * The ranger may begin the countdown at any time, including resetting the countdown to snipe a different location.
   *
   * <dl>
   *     <dt><span class="strong">Throws:</span></dt>
   *     <dd>NoSuchUnit - If either unit does not exist (within the vision range).</dd>
   *     <dd>TeamNotAllowed - If the ranger is not on the current player's team.</dd>
   *     <dd>UnitNotOnMap - If the ranger is not on the map.</dd>
   *     <dd>InappropriateUnitType - If the unit is not a ranger.</dd>
   *     <dd>ResearchNotUnlocked - If you do not have the needed research to use snipe.</dd>
   *     <dd>Overheated - If the ranger is not ready to use snipe again.</dd>
   * </dl>
   */
  public void beginSnipe(int ranger_id, MapLocation location) {
    bcJNI.GameController_beginSnipe(swigCPtr, this, ranger_id, MapLocation.getCPtr(location), location);
  }

  /**
   * Whether the mage can blink to the given location, without taking into account the mage's ability heat.
   * Takes into account only the mage's ability range, the map terrain, positions of other units, and the edge of the game map.
   */
  public boolean canBlink(int mage_id, MapLocation location) {
    return bcJNI.GameController_canBlink(swigCPtr, this, mage_id, MapLocation.getCPtr(location), location);
  }

  /**
   * Whether the mage is ready to blink. Tests whether the mage's ability heat is sufficiently low.
   */
  public boolean isBlinkReady(int mage_id) {
    return bcJNI.GameController_isBlinkReady(swigCPtr, this, mage_id);
  }

  /**
   * Blinks the mage to the given location.
   *
   * <dl>
   *     <dt><span class="strong">Throws:</span></dt>
   *     <dd>NoSuchUnit - If the mage does not exist (within the vision range).</dd>
   *     <dd>TeamNotAllowed - If the mage is not on the current player's team.</dd>
   *     <dd>UnitNotOnMap - If the mage is not on the map.</dd>
   *     <dd>InappropriateUnitType - If the unit is not a mage.</dd>
   *     <dd>ResearchNotUnlocked - If you do not have the needed research to use blink.</dd>
   *     <dd>OutOfRange - If the target does not lie within ability range of the mage.</dd>
   *     <dd>LocationOffMap - If the target location is not on this planet's map.</dd>
   *     <dd>LocationNotVisible - If the target location is outside the vision range.</dd>
   *     <dd>LocationNotEmpty - If the target location is already occupied.</dd>
   *     <dd>Overheated - the mage is not ready to use blink again.</dd>
   * </dl>
   */
  public void blink(int mage_id, MapLocation location) {
    bcJNI.GameController_blink(swigCPtr, this, mage_id, MapLocation.getCPtr(location), location);
  }

  /**
   * Whether the healer can heal the given robot, without taking into account the healer's attack heat.
   * Takes into account only the healer's attack range, and the location of the robot.
   */
  public boolean canHeal(int healer_id, int target_robot_id) {
    return bcJNI.GameController_canHeal(swigCPtr, this, healer_id, target_robot_id);
  }

  /**
   * Whether the healer is ready to heal. Tests whether the healer's attack heat is sufficiently low.
   */
  public boolean isHealReady(int healer_id) {
    return bcJNI.GameController_isHealReady(swigCPtr, this, healer_id);
  }

  /**
   * Commands the healer to heal the target robot.
   *
   * <dl>
   *     <dt><span class="strong">Throws:</span></dt>
   *     <dd>NoSuchUnit - If either unit does not exist (within the vision range).</dd>
   *     <dd>InappropriateUnitType - If the unit is not a healer, or the target is not a robot.</dd>
   *     <dd>TeamNotAllowed - If either unit is not on the current player's team.</dd>
   *     <dd>UnitNotOnMap - If the healer is not on the map.</dd>
   *     <dd>OutOfRange - If the target does not lie within "attack" range of the healer.</dd>
   *     <dd>Overheated - If the healer is not ready to heal again.</dd>
   * </dl>
   */
  public void heal(int healer_id, int target_robot_id) {
    bcJNI.GameController_heal(swigCPtr, this, healer_id, target_robot_id);
  }

  /**
   * Whether the healer can overcharge the given robot, without taking into account the healer's ability heat.
   * Takes into account only the healer's ability range, and the location of the robot.
   */
  public boolean canOvercharge(int healer_id, int target_robot_id) {
    return bcJNI.GameController_canOvercharge(swigCPtr, this, healer_id, target_robot_id);
  }

  /**
   * Whether the healer is ready to overcharge. Tests whether the healer's ability heat is sufficiently low.
   */
  public boolean isOverchargeReady(int healer_id) {
    return bcJNI.GameController_isOverchargeReady(swigCPtr, this, healer_id);
  }

  /**
   * Overcharges the robot, resetting the robot's cooldowns. The robot must be on the same team as you.
   *
   * <dl>
   *     <dt><span class="strong">Throws:</span></dt>
   *     <dd>NoSuchUnit - If either unit does not exist (within the vision range).</dd>
   *     <dd>TeamNotAllowed - If either robot is not on the current player's team.</dd>
   *     <dd>UnitNotOnMap - If the healer is not on the map.</dd>
   *     <dd>InappropriateUnitType - If the unit is not a healer, or the target is not a robot.</dd>
   *     <dd>ResearchNotUnlocked - If you do not have the needed research to use overcharge.</dd>
   *     <dd>OutOfRange - If the target does not lie within ability range of the healer.</dd>
   *     <dd>Overheated - If the knight is not ready to use overcharge again.</dd>
   * </dl>
   */
  public void overcharge(int healer_id, int target_robot_id) {
    bcJNI.GameController_overcharge(swigCPtr, this, healer_id, target_robot_id);
  }

  /**
   * Whether the robot can be loaded into the given structure's garrison.
   * The robot must be ready to move and must be adjacent to the structure.
   * The structure and the robot must be on the same team, and the structure must have space.
   */
  public boolean canLoad(int structure_id, int robot_id) {
    return bcJNI.GameController_canLoad(swigCPtr, this, structure_id, robot_id);
  }

  /**
   * Loads the robot into the garrison of the structure.
   *
   * <dl>
   *     <dt><span class="strong">Throws:</span></dt>
   *     <dd>NoSuchUnit - If either unit does not exist (within the vision range).</dd>
   *     <dd>TeamNotAllowed - If either unit is not on the current player's team.</dd>
   *     <dd>UnitNotOnMap - If the unit is not on the map.</dd>
   *     <dd>Overheated - If the robot is not ready to move again.</dd>
   *     <dd>InappropriateUnitType - If the first unit is not a structure, or the second unit is not a robot.</dd>
   *     <dd>StructureNotYetBuilt - If the structure has not been completed. </dd>
   *     <dd>GarrisonFull - If the structure's garrison is already full.</dd>
   *     <dd>OutOfRange - If the robot is not adjacent to the structure.</dd>
   * </dl>
   */
  public void load(int structure_id, int robot_id) {
    bcJNI.GameController_load(swigCPtr, this, structure_id, robot_id);
  }

  /**
   * Tests whether the given structure is able to unload a unit in the given direction.
   * There must be space in that direction, and the unit must be ready to move.
   */
  public boolean canUnload(int structure_id, Direction direction) {
    return bcJNI.GameController_canUnload(swigCPtr, this, structure_id, direction.swigValue());
  }

  /**
   * Unloads a robot from the garrison of the specified structure into an adjacent space.
   * Robots are unloaded in the order they were loaded.
   *
   * <dl>
   *     <dt><span class="strong">Throws:</span></dt>
   *     <dd>NoSuchUnit - If the unit does not exist (within the vision range).</dd>
   *     <dd>TeamNotAllowed - If either unit is not on the current player's team.</dd>
   *     <dd>UnitNotOnMap - If the structure is not on the map.</dd>
   *     <dd>InappropriateUnitType - If the unit is not a structure.</dd>
   *     <dd>StructureNotYetBuilt - If the structure has not been completed. </dd>
   *     <dd>GarrisonEmpty - If the structure's garrison is already empty.</dd>
   *     <dd>LocationOffMap - If the location in the target direction is off the map.</dd>
   *     <dd>LocationNotEmpty - If the location in the target direction is already occupied.</dd>
   *     <dd>Overheated - If the robot inside the structure is not ready to move again.</dd>
   * </dl>
   */
  public void unload(int structure_id, Direction direction) {
    bcJNI.GameController_unload(swigCPtr, this, structure_id, direction.swigValue());
  }

  /**
   * Whether the factory can produce a robot of the given type.
   * The factory must not currently be producing a robot, and the team must have sufficient resources in its resource pool.
   */
  public boolean canProduceRobot(int factory_id, UnitType robot_type) {
    return bcJNI.GameController_canProduceRobot(swigCPtr, this, factory_id, robot_type.swigValue());
  }

  /**
   * Starts producing the robot of the given type.
   *
   * <dl>
   *     <dt><span class="strong">Throws:</span></dt>
   *     <dd>NoSuchUnit - If the factory does not exist (within the vision range).</dd>
   *     <dd>TeamNotAllowed - If the factory is not on the current player's team.</dd>
   *     <dd>InappropriateUnitType - If the unit is not a factory, or the unit type is not a robot.</dd>
   *     <dd>StructureNotYetBuilt - If the factory has not been completed.</dd>
   *     <dd>FactoryBusy - If the factory is already producing a unit.</dd>
   *     <dd>InsufficientKarbonite - If your team does not have enough Karbonite to produce the given robot.</dd>
   * </dl>
   */
  public void produceRobot(int factory_id, UnitType robot_type) {
    bcJNI.GameController_produceRobot(swigCPtr, this, factory_id, robot_type.swigValue());
  }

  /**
   * The landing rounds and locations of rockets in space that belong to the current team.
   */
  public RocketLandingInfo rocketLandings() {
    long cPtr = bcJNI.GameController_rocketLandings(swigCPtr, this);
    return (cPtr == 0) ? null : new RocketLandingInfo(cPtr, true);
  }

  /**
   * Whether the rocket can launch into space to the given destination.
   * The rocket can launch if the it has never been used before.
   * The destination is valid if it contains passable terrain on the other planet.
   */
  public boolean canLaunchRocket(int rocket_id, MapLocation destination) {
    return bcJNI.GameController_canLaunchRocket(swigCPtr, this, rocket_id, MapLocation.getCPtr(destination), destination);
  }

  /**
   * Launches the rocket into space, damaging the units adjacent to the takeoff location.
   *
   * <dl>
   *     <dt><span class="strong">Throws:</span></dt>
   *     <dd>NoSuchUnit - If the rocket does not exist (within the vision range).</dd>
   *     <dd>TeamNotAllowed - If the rocket is not on the current player's team.</dd>
   *     <dd>SamePlanet - If the rocket cannot fly to a location on the same planet.</dd>
   *     <dd>InappropriateUnitType - If the unit is not a rocket.</dd>
   *     <dd>StructureNotYetBuilt - If the rocket has not been completed. </dd>
   *     <dd>RocketUsed - If the rocket has already been used.</dd>
   *     <dd>LocationOffMap - If the given location is off the map.</dd>
   *     <dd>LocationNotEmpty - If the given location contains impassable terrain.</dd>
   * </dl>
   */
  public void launchRocket(int rocket_id, MapLocation location) {
    bcJNI.GameController_launchRocket(swigCPtr, this, rocket_id, MapLocation.getCPtr(location), location);
  }

  public StartGameMessage startGame(Player player) {
    long cPtr = bcJNI.GameController_startGame(swigCPtr, this, Player.getCPtr(player), player);
    return (cPtr == 0) ? null : new StartGameMessage(cPtr, true);
  }

  public TurnApplication applyTurn(TurnMessage turn, int time_left_ms) {
    long cPtr = bcJNI.GameController_applyTurn(swigCPtr, this, TurnMessage.getCPtr(turn), turn, time_left_ms);
    return (cPtr == 0) ? null : new TurnApplication(cPtr, true);
  }

  public InitialTurnApplication initialStartTurnMessage(int time_left_ms) {
    long cPtr = bcJNI.GameController_initialStartTurnMessage(swigCPtr, this, time_left_ms);
    return (cPtr == 0) ? null : new InitialTurnApplication(cPtr, true);
  }

  public boolean isOver() {
    return bcJNI.GameController_isOver(swigCPtr, this);
  }

  public Team winningTeam() {
    return Team.swigToEnum(bcJNI.GameController_winningTeam(swigCPtr, this));
  }

  public String managerViewerMessage() {
    return bcJNI.GameController_managerViewerMessage(swigCPtr, this);
  }

  public void printGameAnsi() {
    bcJNI.GameController_printGameAnsi(swigCPtr, this);
  }

  public long managerKarbonite(Team team) {
    return bcJNI.GameController_managerKarbonite(swigCPtr, this, team.swigValue());
  }

}
